// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stats.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDistinctSpeciesObserved = `-- name: CountDistinctSpeciesObserved :one
SELECT COUNT(DISTINCT species_id)
FROM observations
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
`

type CountDistinctSpeciesObservedParams struct {
	From pgtype.Timestamp `json:"from"`
	To   pgtype.Timestamp `json:"to"`
}

func (q *Queries) CountDistinctSpeciesObserved(ctx context.Context, arg CountDistinctSpeciesObservedParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDistinctSpeciesObserved, arg.From, arg.To)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSpeciesByNative = `-- name: CountSpeciesByNative :many
SELECT native AS is_native, COUNT(DISTINCT species_id) AS species_count, COUNT(*) AS observation_count
FROM observations_with_details
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
  AND ($3::int IS NULL OR block = $3::int)
GROUP BY native
`

type CountSpeciesByNativeParams struct {
	From  pgtype.Timestamp `json:"from"`
	To    pgtype.Timestamp `json:"to"`
	Block *int32           `json:"block"`
}

type CountSpeciesByNativeRow struct {
	IsNative         bool  `json:"is_native"`
	SpeciesCount     int64 `json:"species_count"`
	ObservationCount int64 `json:"observation_count"`
}

func (q *Queries) CountSpeciesByNative(ctx context.Context, arg CountSpeciesByNativeParams) ([]CountSpeciesByNativeRow, error) {
	rows, err := q.db.Query(ctx, countSpeciesByNative, arg.From, arg.To, arg.Block)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountSpeciesByNativeRow
	for rows.Next() {
		var i CountSpeciesByNativeRow
		if err := rows.Scan(&i.IsNative, &i.SpeciesCount, &i.ObservationCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpeciesCountByTaxa = `-- name: ListSpeciesCountByTaxa :many
SELECT taxa, COUNT(DISTINCT species_id) AS count
FROM observations_with_details
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
  AND ($3::int IS NULL OR block = $3::int)
GROUP BY taxa
`

type ListSpeciesCountByTaxaParams struct {
	From  pgtype.Timestamp `json:"from"`
	To    pgtype.Timestamp `json:"to"`
	Block *int32           `json:"block"`
}

type ListSpeciesCountByTaxaRow struct {
	Taxa  Taxa  `json:"taxa"`
	Count int64 `json:"count"`
}

func (q *Queries) ListSpeciesCountByTaxa(ctx context.Context, arg ListSpeciesCountByTaxaParams) ([]ListSpeciesCountByTaxaRow, error) {
	rows, err := q.db.Query(ctx, listSpeciesCountByTaxa, arg.From, arg.To, arg.Block)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSpeciesCountByTaxaRow
	for rows.Next() {
		var i ListSpeciesCountByTaxaRow
		if err := rows.Scan(&i.Taxa, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const speciesObservationTimeSeries = `-- name: SpeciesObservationTimeSeries :many
SELECT date_trunc('month', "timestamp")::timestamp AS month, COUNT(*) AS count
FROM observations
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
GROUP BY month
ORDER BY month
`

type SpeciesObservationTimeSeriesParams struct {
	From pgtype.Timestamp `json:"from"`
	To   pgtype.Timestamp `json:"to"`
}

type SpeciesObservationTimeSeriesRow struct {
	Month time.Time `json:"month"`
	Count int64     `json:"count"`
}

func (q *Queries) SpeciesObservationTimeSeries(ctx context.Context, arg SpeciesObservationTimeSeriesParams) ([]SpeciesObservationTimeSeriesRow, error) {
	rows, err := q.db.Query(ctx, speciesObservationTimeSeries, arg.From, arg.To)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpeciesObservationTimeSeriesRow
	for rows.Next() {
		var i SpeciesObservationTimeSeriesRow
		if err := rows.Scan(&i.Month, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
