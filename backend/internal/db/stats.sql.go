// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stats.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDistinctSpeciesObserved = `-- name: CountDistinctSpeciesObserved :one
SELECT COUNT(DISTINCT species_id)
FROM observations
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
`

type CountDistinctSpeciesObservedParams struct {
	From pgtype.Timestamp `json:"from"`
	To   pgtype.Timestamp `json:"to"`
}

func (q *Queries) CountDistinctSpeciesObserved(ctx context.Context, arg CountDistinctSpeciesObservedParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDistinctSpeciesObserved, arg.From, arg.To)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSpeciesByNative = `-- name: CountSpeciesByNative :many
SELECT native AS is_native, COUNT(DISTINCT species_id) AS species_count, COUNT(*) AS observation_count
FROM observations_with_details
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
  AND ($3::int IS NULL OR block = $3::int)
  AND ($4::text IS NULL OR site_code = $4)
  AND ($5::taxa IS NULL OR taxa = $5::taxa)
  AND ($6::text IS NULL OR LOWER(common_name) = LOWER($6::text))
GROUP BY native
`

type CountSpeciesByNativeParams struct {
	From       pgtype.Timestamp `json:"from"`
	To         pgtype.Timestamp `json:"to"`
	Block      *int32           `json:"block"`
	SiteCode   *string          `json:"site_code"`
	Taxa       NullTaxa         `json:"taxa"`
	CommonName *string          `json:"common_name"`
}

type CountSpeciesByNativeRow struct {
	IsNative         bool  `json:"is_native"`
	SpeciesCount     int64 `json:"species_count"`
	ObservationCount int64 `json:"observation_count"`
}

func (q *Queries) CountSpeciesByNative(ctx context.Context, arg CountSpeciesByNativeParams) ([]CountSpeciesByNativeRow, error) {
	rows, err := q.db.Query(ctx, countSpeciesByNative,
		arg.From,
		arg.To,
		arg.Block,
		arg.SiteCode,
		arg.Taxa,
		arg.CommonName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountSpeciesByNativeRow
	for rows.Next() {
		var i CountSpeciesByNativeRow
		if err := rows.Scan(&i.IsNative, &i.SpeciesCount, &i.ObservationCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpeciesCountByTaxa = `-- name: ListSpeciesCountByTaxa :many
SELECT taxa, COUNT(DISTINCT species_id) AS count
FROM observations_with_details
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
  AND ($3::int IS NULL OR block = $3::int)
  AND ($4::text IS NULL OR site_code = $4)
  AND ($5::taxa IS NULL OR taxa = $5::taxa)
  AND ($6::text IS NULL OR LOWER(common_name) = LOWER($6::text))
GROUP BY taxa
`

type ListSpeciesCountByTaxaParams struct {
	From       pgtype.Timestamp `json:"from"`
	To         pgtype.Timestamp `json:"to"`
	Block      *int32           `json:"block"`
	SiteCode   *string          `json:"site_code"`
	Taxa       NullTaxa         `json:"taxa"`
	CommonName *string          `json:"common_name"`
}

type ListSpeciesCountByTaxaRow struct {
	Taxa  Taxa  `json:"taxa"`
	Count int64 `json:"count"`
}

func (q *Queries) ListSpeciesCountByTaxa(ctx context.Context, arg ListSpeciesCountByTaxaParams) ([]ListSpeciesCountByTaxaRow, error) {
	rows, err := q.db.Query(ctx, listSpeciesCountByTaxa,
		arg.From,
		arg.To,
		arg.Block,
		arg.SiteCode,
		arg.Taxa,
		arg.CommonName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSpeciesCountByTaxaRow
	for rows.Next() {
		var i ListSpeciesCountByTaxaRow
		if err := rows.Scan(&i.Taxa, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const observationGroupBySites = `-- name: ObservationGroupBySites :many
SELECT site_code, COUNT(DISTINCT species_id) AS species_count, COUNT(*) AS observation_count
FROM observations_with_details
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
  AND ($3::int IS NULL OR block = $3::int)
  AND ($4::text IS NULL OR site_code = $4)
  AND ($5::taxa IS NULL OR taxa = $5::taxa)
  AND ($6::text IS NULL OR LOWER(common_name) = LOWER($6::text))
GROUP BY site_code
`

type ObservationGroupBySitesParams struct {
	From       pgtype.Timestamp `json:"from"`
	To         pgtype.Timestamp `json:"to"`
	Block      *int32           `json:"block"`
	SiteCode   *string          `json:"site_code"`
	Taxa       NullTaxa         `json:"taxa"`
	CommonName *string          `json:"common_name"`
}

type ObservationGroupBySitesRow struct {
	SiteCode         string `json:"site_code"`
	SpeciesCount     int64  `json:"species_count"`
	ObservationCount int64  `json:"observation_count"`
}

func (q *Queries) ObservationGroupBySites(ctx context.Context, arg ObservationGroupBySitesParams) ([]ObservationGroupBySitesRow, error) {
	rows, err := q.db.Query(ctx, observationGroupBySites,
		arg.From,
		arg.To,
		arg.Block,
		arg.SiteCode,
		arg.Taxa,
		arg.CommonName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ObservationGroupBySitesRow
	for rows.Next() {
		var i ObservationGroupBySitesRow
		if err := rows.Scan(&i.SiteCode, &i.SpeciesCount, &i.ObservationCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const observationTimeSeriesGroupByNative = `-- name: ObservationTimeSeriesGroupByNative :many
SELECT native as is_native, date_trunc('year', "timestamp")::timestamp AS year, COUNT(DISTINCT species_id) AS species_count, COUNT(*) AS observation_count
FROM observations_with_details
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
  AND ($3::int IS NULL OR block = $3::int)
  AND ($4::text IS NULL OR site_code = $4)
  AND ($5::taxa IS NULL OR taxa = $5::taxa)
  AND ($6::text IS NULL OR LOWER(common_name) = LOWER($6::text))
GROUP BY year, native
ORDER BY year
`

type ObservationTimeSeriesGroupByNativeParams struct {
	From       pgtype.Timestamp `json:"from"`
	To         pgtype.Timestamp `json:"to"`
	Block      *int32           `json:"block"`
	SiteCode   *string          `json:"site_code"`
	Taxa       NullTaxa         `json:"taxa"`
	CommonName *string          `json:"common_name"`
}

type ObservationTimeSeriesGroupByNativeRow struct {
	IsNative         bool      `json:"is_native"`
	Year             time.Time `json:"year"`
	SpeciesCount     int64     `json:"species_count"`
	ObservationCount int64     `json:"observation_count"`
}

func (q *Queries) ObservationTimeSeriesGroupByNative(ctx context.Context, arg ObservationTimeSeriesGroupByNativeParams) ([]ObservationTimeSeriesGroupByNativeRow, error) {
	rows, err := q.db.Query(ctx, observationTimeSeriesGroupByNative,
		arg.From,
		arg.To,
		arg.Block,
		arg.SiteCode,
		arg.Taxa,
		arg.CommonName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ObservationTimeSeriesGroupByNativeRow
	for rows.Next() {
		var i ObservationTimeSeriesGroupByNativeRow
		if err := rows.Scan(
			&i.IsNative,
			&i.Year,
			&i.SpeciesCount,
			&i.ObservationCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
