// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: observation.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countObservations = `-- name: CountObservations :one
SELECT COUNT(*) FROM observations
`

func (q *Queries) CountObservations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countObservations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countObservationsBySite = `-- name: CountObservationsBySite :one
SELECT COUNT(*) FROM observations
WHERE site_id = $1
`

func (q *Queries) CountObservationsBySite(ctx context.Context, siteID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countObservationsBySite, siteID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countObservationsBySpecies = `-- name: CountObservationsBySpecies :one
SELECT COUNT(*) FROM observations
WHERE species_id = $1
`

func (q *Queries) CountObservationsBySpecies(ctx context.Context, speciesID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countObservationsBySpecies, speciesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createObservation = `-- name: CreateObservation :one
INSERT INTO observations (
  site_id,
  species_id,
  "timestamp",
  method,
  appearance_start,
  appearance_end,
  temperature,
  narrative,
  confidence
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, site_id, species_id, "timestamp", method, appearance_start, appearance_end, temperature, narrative, confidence
`

type CreateObservationParams struct {
	SiteID          int64             `json:"site_id"`
	SpeciesID       int64             `json:"species_id"`
	Timestamp       time.Time         `json:"timestamp"`
	Method          ObservationMethod `json:"method"`
	AppearanceStart *int32            `json:"appearance_start"`
	AppearanceEnd   *int32            `json:"appearance_end"`
	Temperature     *int32            `json:"temperature"`
	Narrative       *string           `json:"narrative"`
	Confidence      *float32          `json:"confidence"`
}

func (q *Queries) CreateObservation(ctx context.Context, arg CreateObservationParams) (Observation, error) {
	row := q.db.QueryRow(ctx, createObservation,
		arg.SiteID,
		arg.SpeciesID,
		arg.Timestamp,
		arg.Method,
		arg.AppearanceStart,
		arg.AppearanceEnd,
		arg.Temperature,
		arg.Narrative,
		arg.Confidence,
	)
	var i Observation
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.SpeciesID,
		&i.Timestamp,
		&i.Method,
		&i.AppearanceStart,
		&i.AppearanceEnd,
		&i.Temperature,
		&i.Narrative,
		&i.Confidence,
	)
	return i, err
}

type CreateObservationsParams struct {
	SiteID          int64             `json:"site_id"`
	SpeciesID       int64             `json:"species_id"`
	Timestamp       time.Time         `json:"timestamp"`
	Method          ObservationMethod `json:"method"`
	AppearanceStart *int32            `json:"appearance_start"`
	AppearanceEnd   *int32            `json:"appearance_end"`
	Temperature     *int32            `json:"temperature"`
	Narrative       *string           `json:"narrative"`
	Confidence      *float32          `json:"confidence"`
}

const deleteObservation = `-- name: DeleteObservation :exec
DELETE FROM observations
WHERE id = $1
`

func (q *Queries) DeleteObservation(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteObservation, id)
	return err
}

const getObservation = `-- name: GetObservation :one
SELECT id, site_id, species_id, "timestamp", method, appearance_start, appearance_end, temperature, narrative, confidence
FROM observations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetObservation(ctx context.Context, id int64) (Observation, error) {
	row := q.db.QueryRow(ctx, getObservation, id)
	var i Observation
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.SpeciesID,
		&i.Timestamp,
		&i.Method,
		&i.AppearanceStart,
		&i.AppearanceEnd,
		&i.Temperature,
		&i.Narrative,
		&i.Confidence,
	)
	return i, err
}

const listObservations = `-- name: ListObservations :many
SELECT id, site_id, species_id, "timestamp", method, appearance_start, appearance_end, temperature, narrative, confidence
FROM observations
ORDER BY timestamp
LIMIT $1
OFFSET $2
`

type ListObservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListObservations(ctx context.Context, arg ListObservationsParams) ([]Observation, error) {
	rows, err := q.db.Query(ctx, listObservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Observation
	for rows.Next() {
		var i Observation
		if err := rows.Scan(
			&i.ID,
			&i.SiteID,
			&i.SpeciesID,
			&i.Timestamp,
			&i.Method,
			&i.AppearanceStart,
			&i.AppearanceEnd,
			&i.Temperature,
			&i.Narrative,
			&i.Confidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const observationTimeSeries = `-- name: ObservationTimeSeries :many
SELECT date_trunc('month', "timestamp")::timestamp AS month, COUNT(*) AS count
FROM observations
WHERE ($1::timestamp IS NULL OR "timestamp" >= $1::timestamp)
  AND ($2::timestamp IS NULL OR "timestamp" <= $2::timestamp)
GROUP BY month
ORDER BY month
`

type ObservationTimeSeriesParams struct {
	From pgtype.Timestamp `json:"from"`
	To   pgtype.Timestamp `json:"to"`
}

type ObservationTimeSeriesRow struct {
	Month time.Time `json:"month"`
	Count int64     `json:"count"`
}

func (q *Queries) ObservationTimeSeries(ctx context.Context, arg ObservationTimeSeriesParams) ([]ObservationTimeSeriesRow, error) {
	rows, err := q.db.Query(ctx, observationTimeSeries, arg.From, arg.To)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ObservationTimeSeriesRow
	for rows.Next() {
		var i ObservationTimeSeriesRow
		if err := rows.Scan(&i.Month, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchObservations = `-- name: SearchObservations :many
SELECT o.id, o.site_id, o.species_id, o.timestamp, o.method, o.appearance_start, o.appearance_end, o.temperature, o.narrative, o.confidence, s.code as site_code, s.name as site_name, sp.scientific_name, sp.common_name, sp.taxa
FROM observations o
JOIN sites s ON o.site_id = s.id
JOIN species sp ON o.species_id = sp.id
WHERE sp.scientific_name ILIKE $1 OR sp.common_name ILIKE $1 OR o.narrative ILIKE $1
ORDER BY o.timestamp DESC
`

type SearchObservationsRow struct {
	ID              int64             `json:"id"`
	SiteID          int64             `json:"site_id"`
	SpeciesID       int64             `json:"species_id"`
	Timestamp       time.Time         `json:"timestamp"`
	Method          ObservationMethod `json:"method"`
	AppearanceStart *int32            `json:"appearance_start"`
	AppearanceEnd   *int32            `json:"appearance_end"`
	Temperature     *int32            `json:"temperature"`
	Narrative       *string           `json:"narrative"`
	Confidence      *float32          `json:"confidence"`
	SiteCode        string            `json:"site_code"`
	SiteName        *string           `json:"site_name"`
	ScientificName  string            `json:"scientific_name"`
	CommonName      string            `json:"common_name"`
	Taxa            Taxa              `json:"taxa"`
}

func (q *Queries) SearchObservations(ctx context.Context, scientificName string) ([]SearchObservationsRow, error) {
	rows, err := q.db.Query(ctx, searchObservations, scientificName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchObservationsRow
	for rows.Next() {
		var i SearchObservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.SiteID,
			&i.SpeciesID,
			&i.Timestamp,
			&i.Method,
			&i.AppearanceStart,
			&i.AppearanceEnd,
			&i.Temperature,
			&i.Narrative,
			&i.Confidence,
			&i.SiteCode,
			&i.SiteName,
			&i.ScientificName,
			&i.CommonName,
			&i.Taxa,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObservation = `-- name: UpdateObservation :one
UPDATE observations
SET site_id = $2,
    species_id = $3,
    "timestamp" = $4,
    method = $5,
    appearance_start = $6,
    appearance_end = $7,
    temperature = $8,
    narrative = $9,
    confidence = $10
WHERE id = $1
RETURNING id, site_id, species_id, "timestamp", method, appearance_start, appearance_end, temperature, narrative, confidence
`

type UpdateObservationParams struct {
	ID              int64             `json:"id"`
	SiteID          int64             `json:"site_id"`
	SpeciesID       int64             `json:"species_id"`
	Timestamp       time.Time         `json:"timestamp"`
	Method          ObservationMethod `json:"method"`
	AppearanceStart *int32            `json:"appearance_start"`
	AppearanceEnd   *int32            `json:"appearance_end"`
	Temperature     *int32            `json:"temperature"`
	Narrative       *string           `json:"narrative"`
	Confidence      *float32          `json:"confidence"`
}

func (q *Queries) UpdateObservation(ctx context.Context, arg UpdateObservationParams) (Observation, error) {
	row := q.db.QueryRow(ctx, updateObservation,
		arg.ID,
		arg.SiteID,
		arg.SpeciesID,
		arg.Timestamp,
		arg.Method,
		arg.AppearanceStart,
		arg.AppearanceEnd,
		arg.Temperature,
		arg.Narrative,
		arg.Confidence,
	)
	var i Observation
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.SpeciesID,
		&i.Timestamp,
		&i.Method,
		&i.AppearanceStart,
		&i.AppearanceEnd,
		&i.Temperature,
		&i.Narrative,
		&i.Confidence,
	)
	return i, err
}
